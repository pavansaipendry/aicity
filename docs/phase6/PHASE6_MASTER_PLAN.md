# AIcity — Phase 6: Visual City Rebuild
## Master Plan of Action — Complete Technical Reference

> **Status**: Planned
> **Goal**: Replace the flat top-down Phaser prototype with a SimCity 4-quality
> isometric city that agents physically build, inhabit, and fight over — live,
> in the browser.
> **Author**: Generated by Claude Sonnet 4.6, February 2026
> **Target model for implementation**: Claude Sonnet 4.6 or Opus 4.6
> **Asset strategy**: Path A — Free (Kenney.nl isometric packs)

---

## Table of Contents

1. [Vision](#1-vision)
2. [What Phase 5 Gave Us (Keep vs Replace)](#2-what-phase-5-gave-us)
3. [Tech Stack — Every Tool with Version](#3-tech-stack)
4. [Asset Pipeline — Every File You Need](#4-asset-pipeline)
5. [Architecture Overview](#5-architecture-overview)
6. [Database Schema Changes](#6-database-schema-changes)
7. [Backend Changes — Every File](#7-backend-changes)
8. [New WebSocket Event Protocol](#8-websocket-event-protocol)
9. [Frontend — New Project Structure](#9-frontend-structure)
10. [Isometric Engine Design](#10-isometric-engine-design)
11. [Character Sprite System](#11-character-sprite-system)
12. [Construction System Design](#12-construction-system-design)
13. [Pathfinding System](#13-pathfinding-system)
14. [Sprint-by-Sprint Plan](#14-sprint-plan)
15. [Every File to Create / Modify](#15-file-manifest)
16. [Environment Setup — Step by Step](#16-environment-setup)
17. [Testing Strategy](#17-testing-strategy)
18. [Performance Targets](#18-performance-targets)
19. [Known Hard Problems](#19-known-hard-problems)

---

## 1. Vision

### What the player sees

| Day | What happens |
|-----|-------------|
| 1 | Empty grass field. A river cuts through the centre. Ten agents spawn and wander. |
| 2 | Builders meet at the river bank. Speech bubble: *"We need a bridge."* They begin staking out ground. |
| 3–5 | Bridge construction is visible — scaffolding appears first, then stone tiles, then railings. Two builders work simultaneously; you can see them hammering. |
| 6 | Market opens. The merchant walks inside. A sign goes up. |
| 8 | Villain lurks in the dark alley. Police patrols. A chase erupts — both pathfind through real streets. Villain caught at the bridge. |
| 14 | A school stands next to the market. New agents are born and walk to school each morning. |
| 30 | A real city: roads, buildings, parks, a police station, homes owned by individual agents. Every structure was a decision made by an LLM. |

### What makes it feel real

- **Isometric perspective** — buildings have walls, depth, and shadows. Not top-down flat.
- **High-resolution sprite art** — Kenney's isometric city kit (same quality as SimCity 4 screenshot).
- **Real pathfinding** — agents walk along roads, go around buildings. No teleporting.
- **Construction takes time** — a building goes through 5 visual stages over multiple days. More builders = faster.
- **Speech bubbles in the world** — you see conversations happening above agents' heads.
- **Police chases are physical** — watch the pursuit through streets in real-time.

---

## 2. What Phase 5 Gave Us

### KEEP — Backend is solid

```
src/
  agents/          ← LLM brain system — keep entirely
  economy/         ← token engine, projects — keep
  justice/         ← court system — keep
  os/              ← city orchestrator — keep (add construction hooks)
  migrations/      ← DB schema — keep, add 3 new migrations
  dashboard/
    server.py      ← FastAPI + WebSocket — keep, add new event types
```

### REPLACE — Entire frontend visual layer

```
src/dashboard/static/game/   ← DELETE everything inside, rebuild with Vite + PixiJS
src/dashboard/static/app.css ← Keep dashboard CSS, remove game-specific styles
src/dashboard/static/index.html ← Keep HTML shell, replace game mount point
```

The Python backend, PostgreSQL, and WebSocket infrastructure are production-quality.
Only the visual rendering layer changes.

---

## 3. Tech Stack

### Every tool, version, install command, and why

#### 3.1 Frontend — Rendering

| Tool | Version | Install | Why |
|------|---------|---------|-----|
| **Vite** | 5.x | `npm create vite@latest aicity-game -- --template vanilla-ts` | Instant HMR, ES modules, replaces CDN scripts |
| **TypeScript** | 5.x | included with Vite template | Catches type errors before runtime in complex game code |
| **PixiJS** | 8.x | `npm install pixi.js@8` | WebGL/WebGPU 2D renderer — handles 100k+ sprites at 60fps |
| **@pixi/spritesheet** | 8.x | bundled with pixi.js | Sprite sheet animation management |

```bash
# Full frontend setup (run from aicity/ project root)
mkdir src/dashboard/static/game-v2
cd src/dashboard/static/game-v2
npm create vite@latest . -- --template vanilla-ts
npm install pixi.js@8
npm install easystarjs          # pathfinding
npm install simplex-noise       # terrain generation
npm install @types/easystarjs   # TypeScript types
```

#### 3.2 Isometric Engine

No external library needed. We write ~200 lines of coordinate math.
Isometric projection is simple math:

```typescript
// Tile (col, row) → screen (x, y)
screenX = (col - row) * (TILE_W / 2)
screenY = (col + row) * (TILE_H / 2)
```

Full implementation in `src/engine/IsoGrid.ts` (see §10).

#### 3.3 Backend additions

| Tool | Version | Install | Why |
|------|---------|---------|-----|
| **Redis** | 7.x | `brew install redis` or Docker | Pub/sub for WebSocket fanout — faster than Python asyncio broadcast |
| **redis-py** | 5.x | `pip install redis` | Python Redis client |
| **Celery** | 5.x | `pip install celery[redis]` | Parallel agent task queue — agents run concurrently, not sequentially |

```bash
# Start Redis (Mac)
brew services start redis

# Or via Docker (any OS)
docker run -d -p 6379:6379 --name redis redis:7-alpine

# Install Python deps
pip install redis celery[redis]
```

> **Note**: If you don't want Redis complexity, skip Celery for now.
> The server.py asyncio broadcast works fine up to ~50 connected clients.
> Add Redis only when you need scale or parallel agent processing.

#### 3.4 AI Layer

| Model | Use case | Cost |
|-------|---------|------|
| `claude-opus-4-6` | Mayor, Judge, Villain mastermind — complex strategy | ~$15/M tokens |
| `claude-sonnet-4-6` | Standard agents (builders, police, merchants) | ~$3/M tokens |
| `claude-haiku-4-5-20251001` | Newborns, background chatter, routine decisions | ~$0.25/M tokens |

**LangGraph** (optional, for construction coordination):

```bash
pip install langgraph langchain-anthropic
```

LangGraph is a state machine framework for multi-agent workflows. Use it if you
want builders to coordinate project steps as a proper graph of decisions. Not
required for Sprint 1.

#### 3.5 Pixel art tooling (for custom sprites later)

| Tool | Cost | Use |
|------|------|-----|
| **Piskel** | Free (browser) | piskelapp.com — draw 16×16 / 32×32 pixel art |
| **Aseprite** | $20 | Industry standard pixel art editor with animation support |
| **LibreSprite** | Free | Open-source Aseprite fork |

For Phase 6 Path A we use Kenney's free pre-made sprites. Piskel is only needed
if/when you want to draw custom characters.

---

## 4. Asset Pipeline

### 4.1 Download these exact packs from kenney.nl

All free, all CC0 (public domain). No attribution required.

| Pack | URL | What's in it |
|------|-----|-------------|
| **Isometric City Kit** | https://kenney.nl/assets/isometric-city-kit | 127 tiles: roads, buildings, sidewalks, bridges |
| **Isometric Landscape** | https://kenney.nl/assets/isometric-landscape | Grass, water, sand, dirt, trees, rocks, hills |
| **Isometric Characters** | https://kenney.nl/assets/isometric-characters | 28 characters in 8 directions, multiple skin tones |
| **Isometric Vehicles** | https://kenney.nl/assets/isometric-vehicles | Cars, trucks, buses (for later sprints) |

### 4.2 File organisation after download

```
src/dashboard/static/game-v2/public/assets/
├── tiles/
│   ├── ground/
│   │   ├── grass.png           # base grass tile (64×32 px isometric)
│   │   ├── grass_dark.png
│   │   ├── water.png
│   │   ├── sand.png
│   │   └── dirt.png
│   ├── roads/
│   │   ├── road_straight_ns.png
│   │   ├── road_straight_ew.png
│   │   ├── road_corner_ne.png
│   │   ├── road_corner_nw.png
│   │   ├── road_corner_se.png
│   │   ├── road_corner_sw.png
│   │   ├── road_t_n.png
│   │   ├── road_t_s.png
│   │   ├── road_t_e.png
│   │   ├── road_t_w.png
│   │   └── road_cross.png
│   ├── buildings/
│   │   ├── house_small.png
│   │   ├── house_medium.png
│   │   ├── shop.png
│   │   ├── hospital.png
│   │   ├── school.png
│   │   ├── police_station.png
│   │   ├── market.png
│   │   ├── warehouse.png
│   │   └── construction/
│   │       ├── stage_0_stakes.png      # just wooden stakes in ground
│   │       ├── stage_1_foundation.png  # concrete slab
│   │       ├── stage_2_frame.png       # steel/wood frame
│   │       ├── stage_3_walls.png       # walls up, no roof
│   │       └── stage_4_roof.png        # finished (= building sprite)
│   └── nature/
│       ├── tree_oak.png
│       ├── tree_pine.png
│       ├── bush.png
│       └── rock.png
├── characters/
│   ├── spritesheet.json        # Kenney character spritesheet atlas
│   ├── spritesheet.png
│   └── role_map.json           # maps role names to sprite indices
└── ui/
    ├── speech_bubble.png
    ├── construction_bar.png
    └── minimap_dot.png
```

### 4.3 Kenney tile dimensions

Kenney's isometric tiles are **64×32 pixels** (2:1 ratio).
The diamond (rhombus) ground tile is 64px wide, 32px tall.
Buildings are taller — a 1-story building sprite is ~64×64px.

```typescript
// src/engine/IsoGrid.ts
export const TILE_W = 64;   // tile width in pixels
export const TILE_H = 32;   // tile height in pixels (half of width — isometric)
export const TILE_DEPTH = 16;  // extra height for wall sides
```

### 4.4 Sprite atlas workflow

Kenney provides individual PNGs. Use **TexturePacker** (free tier) or
**PixiJS's built-in spritesheet** format to pack them into one atlas.

For development, loading individual PNGs is fine. For production, pack into atlas.

```typescript
// Loading individual asset example (development)
const texture = await Assets.load('/assets/tiles/ground/grass.png');

// Loading atlas (production)
await Assets.load('/assets/atlas/tiles.json');  // points to tiles.png spritesheet
const grassTexture = Texture.from('grass');
```

---

## 5. Architecture Overview

```
┌──────────────────────────────────────────────────────────────────────────────┐
│  BROWSER                                                                      │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Vite + TypeScript (src/dashboard/static/game-v2/)                   │   │
│  │                                                                      │   │
│  │  ┌─────────────┐   ┌──────────────────────────────────────────────┐ │   │
│  │  │  Dashboard  │   │  PixiJS v8 Application                       │ │   │
│  │  │  (app.js)   │   │                                              │ │   │
│  │  │             │   │  ┌──────────────┐  ┌────────────────────┐   │ │   │
│  │  │  Citizens   │   │  │  IsoWorld    │  │  CharacterManager  │   │ │   │
│  │  │  Events     │   │  │  (tile grid) │  │  (sprites + anim)  │   │ │   │
│  │  │  Relations  │   │  └──────────────┘  └────────────────────┘   │ │   │
│  │  │  Newspaper  │   │  ┌──────────────┐  ┌────────────────────┐   │ │   │
│  │  │  Archives   │   │  │  PathFinder  │  │  ConstructionMgr   │   │ │   │
│  │  │             │   │  │  (EasyStar)  │  │  (build stages)    │   │ │   │
│  │  └─────────────┘   │  └──────────────┘  └────────────────────┘   │ │   │
│  │       ↕ events     │  ┌──────────────┐  ┌────────────────────┐   │ │   │
│  │  ┌─────────────┐   │  │  SpeechBubble│  │  CameraController  │   │ │   │
│  │  │  WS Client  │   │  │  System      │  │  (pan + zoom)      │   │ │   │
│  │  │  (shared)   │   │  └──────────────┘  └────────────────────┘   │ │   │
│  │  └──────┬──────┘   └──────────────────────────────────────────────┘ │   │
│  └─────────┼────────────────────────────────────────────────────────────┘   │
└────────────┼────────────────────────────────────────────────────────────────┘
             │ WebSocket (ws://localhost:8000/ws)
┌────────────┼────────────────────────────────────────────────────────────────┐
│  PYTHON BACKEND                                                               │
│             │                                                                │
│  ┌──────────┴──────────────────────────────────────────────────────────┐   │
│  │  FastAPI (src/dashboard/server.py)                                   │   │
│  │  • /ws  WebSocket endpoint                                           │   │
│  │  • /api/world  → GET world tile state                                │   │
│  │  • /api/construction → GET all active projects                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│             ↕ SQL                                                            │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  PostgreSQL                                                           │   │
│  │  agents | world_tiles | construction_projects | road_segments        │   │
│  │  messages | newspapers | crimes | token_transactions | relationships  │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│             ↕ Claude API                                                     │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Agent Brain (src/agents/brain.py)                                    │   │
│  │  Opus 4.6 / Sonnet 4.6 / Haiku 4.5 — per role                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. Database Schema Changes

### 6.1 New migration: `009_world_tiles.sql`

```sql
-- src/migrations/009_world_tiles.sql
-- Stores the state of every tile in the world grid.
-- The grid is 128×128 tiles. Tiles are addressed by (col, row).

CREATE TABLE IF NOT EXISTS world_tiles (
    id          SERIAL PRIMARY KEY,
    col         INTEGER NOT NULL,
    row         INTEGER NOT NULL,
    tile_type   VARCHAR(64) NOT NULL DEFAULT 'grass',
    -- tile_type values:
    --   grass, grass_dark, water, sand, dirt       ← ground
    --   road_ns, road_ew, road_ne, road_nw,        ← roads
    --   road_se, road_sw, road_t_n, road_t_s,
    --   road_t_e, road_t_w, road_cross
    --   tree_oak, tree_pine, bush, rock             ← nature
    --   house_small, shop, hospital, school,        ← buildings
    --   police_station, market, warehouse
    layer       INTEGER NOT NULL DEFAULT 0,
    -- layer 0 = ground, 1 = road/path, 2 = nature, 3 = building
    built_by    VARCHAR(128),                       -- agent name who placed it
    built_day   INTEGER,
    created_at  TIMESTAMP DEFAULT NOW(),
    updated_at  TIMESTAMP DEFAULT NOW(),
    UNIQUE (col, row, layer)
);

CREATE INDEX idx_world_tiles_position ON world_tiles (col, row);
```

### 6.2 New migration: `010_construction_projects.sql`

```sql
-- src/migrations/010_construction_projects.sql
-- Tracks every construction project from planning to completion.
-- Multi-agent coordination: multiple builders can contribute.

CREATE TABLE IF NOT EXISTS construction_projects (
    id              SERIAL PRIMARY KEY,
    name            VARCHAR(256) NOT NULL,
    -- e.g. "Market Stall", "Bridge over river", "South Road"
    project_type    VARCHAR(64) NOT NULL,
    -- e.g. "market", "bridge", "road", "house", "school"
    status          VARCHAR(32) NOT NULL DEFAULT 'planned',
    -- planned → surveying → foundation → framing → finishing → complete
    stage           INTEGER NOT NULL DEFAULT 0,
    -- 0=planned, 1=stakes, 2=foundation, 3=frame, 4=walls, 5=complete
    total_stages    INTEGER NOT NULL DEFAULT 5,
    progress_pct    FLOAT NOT NULL DEFAULT 0.0,
    -- 0.0 to 100.0

    -- Location on the tile grid
    start_col       INTEGER NOT NULL,
    start_row       INTEGER NOT NULL,
    width_tiles     INTEGER NOT NULL DEFAULT 2,  -- footprint width
    height_tiles    INTEGER NOT NULL DEFAULT 2,  -- footprint depth

    -- Coordination
    proposed_by     VARCHAR(128) NOT NULL,       -- agent who proposed it
    assigned_builders JSONB DEFAULT '[]',        -- ["Kai Fox", "Atlas Grey"]
    builder_days    INTEGER NOT NULL DEFAULT 0,  -- total builder-days spent
    days_required   INTEGER NOT NULL DEFAULT 5,  -- decreases with more builders
    -- Formula: days_required = base_days / sqrt(num_builders)

    created_day     INTEGER,
    completed_day   INTEGER,
    created_at      TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_construction_status ON construction_projects (status);
CREATE INDEX idx_construction_location ON construction_projects (start_col, start_row);
```

### 6.3 New migration: `011_road_network.sql`

```sql
-- src/migrations/011_road_network.sql
-- Road segments for pathfinding graph.
-- Updated whenever a road tile is placed.

CREATE TABLE IF NOT EXISTS road_segments (
    id          SERIAL PRIMARY KEY,
    from_col    INTEGER NOT NULL,
    from_row    INTEGER NOT NULL,
    to_col      INTEGER NOT NULL,
    to_row      INTEGER NOT NULL,
    road_type   VARCHAR(32) DEFAULT 'dirt_path',
    -- dirt_path, paved_road, highway
    passable    BOOLEAN DEFAULT TRUE,
    created_day INTEGER,
    created_at  TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_road_from ON road_segments (from_col, from_row);
CREATE INDEX idx_road_to ON road_segments (to_col, to_row);
```

### 6.4 Add columns to existing `agents` table

```sql
-- Add to agents table (can be a new migration 012_agent_world_position.sql)

ALTER TABLE agents
    ADD COLUMN IF NOT EXISTS world_col     INTEGER DEFAULT 32,
    ADD COLUMN IF NOT EXISTS world_row     INTEGER DEFAULT 32,
    ADD COLUMN IF NOT EXISTS home_col      INTEGER,
    ADD COLUMN IF NOT EXISTS home_row      INTEGER,
    ADD COLUMN IF NOT EXISTS current_action VARCHAR(64) DEFAULT 'idle',
    -- idle, walking, building, talking, chasing, fleeing, sleeping
    ADD COLUMN IF NOT EXISTS facing_dir    VARCHAR(8) DEFAULT 'south';
    -- north, south, east, west (for sprite direction)
```

---

## 7. Backend Changes

### 7.1 New file: `src/world/tile_manager.py`

This module owns all tile state. Other modules call it to read/write the world.

```python
# src/world/tile_manager.py
"""
World tile manager.
Owns the 128×128 tile grid stored in PostgreSQL.
Provides methods to read tiles, place tiles, and generate the initial world.
"""
import psycopg2
import json
import random
from typing import Optional
from src.db import get_conn   # existing DB connection helper


GRID_COLS = 128
GRID_ROWS = 128

# Tile layers
LAYER_GROUND   = 0
LAYER_PATH     = 1
LAYER_NATURE   = 2
LAYER_BUILDING = 3


def get_world_state() -> list[dict]:
    """Return all non-grass tiles as a list.
    Grass is the default — we only store non-grass tiles for efficiency.
    Returns: [{ col, row, layer, tile_type, built_by, built_day }]
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT col, row, tile_type, layer, built_by, built_day
                FROM world_tiles
                ORDER BY layer, row, col
            """)
            rows = cur.fetchall()
    return [
        {"col": r[0], "row": r[1], "tile_type": r[2],
         "layer": r[3], "built_by": r[4], "built_day": r[5]}
        for r in rows
    ]


def place_tile(col: int, row: int, tile_type: str,
               layer: int = LAYER_GROUND,
               built_by: Optional[str] = None,
               built_day: Optional[int] = None) -> dict:
    """
    Place or update a single tile.
    Returns the tile dict that was placed (for WebSocket broadcasting).
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO world_tiles (col, row, tile_type, layer, built_by, built_day)
                VALUES (%s, %s, %s, %s, %s, %s)
                ON CONFLICT (col, row, layer)
                DO UPDATE SET tile_type = EXCLUDED.tile_type,
                              built_by  = EXCLUDED.built_by,
                              built_day = EXCLUDED.built_day,
                              updated_at = NOW()
                RETURNING col, row, tile_type, layer, built_by, built_day
            """, (col, row, tile_type, layer, built_by, built_day))
            row_data = cur.fetchone()
        conn.commit()
    return {
        "col": row_data[0], "row": row_data[1],
        "tile_type": row_data[2], "layer": row_data[3],
        "built_by": row_data[4], "built_day": row_data[5]
    }


def generate_initial_world(day: int = 0):
    """
    Called once on first boot (when world_tiles is empty).
    Generates:
      - River running roughly N-S through col ~60
      - Two small hills (dirt patches)
      - Scattered trees (nature layer)
      - No roads, no buildings
    Everything else is grass (default, not stored).
    """
    tiles_to_place = []

    # River: a winding N-S strip around col 58-62
    for row in range(GRID_ROWS):
        wobble = int(3 * math.sin(row * 0.15))  # gentle curve
        for dc in range(-2, 3):
            col = 60 + wobble + dc
            if 0 <= col < GRID_COLS:
                tiles_to_place.append((col, row, "water", LAYER_GROUND))

    # Two hills: dirt patches with rocks
    for hill_col, hill_row in [(25, 20), (90, 75)]:
        for dc in range(-4, 5):
            for dr in range(-3, 4):
                if dc*dc + dr*dr <= 16:  # circular patch
                    tiles_to_place.append(
                        (hill_col + dc, hill_row + dr, "dirt", LAYER_GROUND))

    # Scattered trees (avoid water tiles)
    random.seed(42)  # reproducible
    water_cols = {(60 + int(3*math.sin(r*0.15)) + dc, r)
                  for r in range(GRID_ROWS) for dc in range(-2,3)}
    for _ in range(180):
        col = random.randint(0, GRID_COLS - 1)
        row = random.randint(0, GRID_ROWS - 1)
        if (col, row) not in water_cols:
            tree = "tree_oak" if random.random() < 0.6 else "tree_pine"
            tiles_to_place.append((col, row, tree, LAYER_NATURE))

    # Insert all at once
    with get_conn() as conn:
        with conn.cursor() as cur:
            for col, row, tile_type, layer in tiles_to_place:
                cur.execute("""
                    INSERT INTO world_tiles (col, row, tile_type, layer, built_day)
                    VALUES (%s, %s, %s, %s, %s)
                    ON CONFLICT (col, row, layer) DO NOTHING
                """, (col, row, tile_type, layer, day))
        conn.commit()

    return len(tiles_to_place)
```

### 7.2 New file: `src/world/construction_manager.py`

```python
# src/world/construction_manager.py
"""
Construction project manager.
Handles multi-agent building coordination.
Rules:
  - Any agent (typically builders) can propose a project.
  - Multiple agents can be assigned as builders.
  - Each builder's daily action contributes 1 builder-day.
  - Required days = ceil(base_days / sqrt(num_builders))
  - After required_days of builder-days, stage advances.
  - 5 stages total: stakes → foundation → frame → walls → complete
"""
import math
import json
from src.db import get_conn


BASE_DAYS_PER_STAGE = {
    "house":          2,   # 2 builder-days per stage
    "road":           1,   # roads are fast
    "bridge":         4,   # bridges need more work
    "market":         3,
    "school":         5,
    "hospital":       5,
    "police_station": 4,
    "warehouse":      3,
    "park":           1,
}
DEFAULT_BASE_DAYS = 3

BUILDING_TILE_MAP = {
    "house":          "house_small",
    "market":         "market",
    "school":         "school",
    "hospital":       "hospital",
    "police_station": "police_station",
    "warehouse":      "warehouse",
    "park":           "tree_oak",
}


def propose_project(name: str, project_type: str,
                    start_col: int, start_row: int,
                    width: int, height: int,
                    proposed_by: str, day: int) -> dict:
    """Create a new construction project in 'planned' status."""
    base = BASE_DAYS_PER_STAGE.get(project_type, DEFAULT_BASE_DAYS)
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO construction_projects
                  (name, project_type, status, stage, progress_pct,
                   start_col, start_row, width_tiles, height_tiles,
                   proposed_by, assigned_builders, builder_days,
                   days_required, created_day)
                VALUES (%s,%s,'planned',0,0,%s,%s,%s,%s,%s,'[]',0,%s,%s)
                RETURNING id
            """, (name, project_type, start_col, start_row,
                  width, height, proposed_by, base * 5, day))
            pid = cur.fetchone()[0]
        conn.commit()
    return get_project(pid)


def assign_builder(project_id: int, builder_name: str):
    """Add a builder to a project's assigned list."""
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                UPDATE construction_projects
                SET assigned_builders = (
                    SELECT jsonb_agg(DISTINCT elem)
                    FROM jsonb_array_elements(
                        assigned_builders || %s::jsonb
                    ) AS elem
                ),
                status = CASE WHEN status = 'planned' THEN 'surveying' ELSE status END
                WHERE id = %s
            """, (json.dumps([builder_name]), project_id))
        conn.commit()


def advance_project(project_id: int, day: int) -> dict:
    """
    Called each day for each assigned builder working on this project.
    Increments builder_days. If enough days have passed, advances to next stage.
    Emits tile updates when stage changes.
    Returns the updated project dict.
    """
    project = get_project(project_id)
    if not project or project["status"] == "complete":
        return project

    num_builders = max(1, len(project["assigned_builders"]))
    # Speed formula: more builders = fewer days needed
    effective_days_required = math.ceil(
        BASE_DAYS_PER_STAGE.get(project["project_type"], DEFAULT_BASE_DAYS)
        / math.sqrt(num_builders)
    )

    new_builder_days = project["builder_days"] + 1
    current_stage = project["stage"]

    # Check if we advance to next stage
    stage_complete = (new_builder_days % effective_days_required == 0)
    new_stage = min(current_stage + (1 if stage_complete else 0), 5)

    status_map = {0:"planned",1:"surveying",2:"foundation",3:"framing",4:"finishing",5:"complete"}
    new_status = status_map.get(new_stage, "complete")
    pct = (new_stage / 5) * 100

    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                UPDATE construction_projects
                SET builder_days = %s, stage = %s, status = %s,
                    progress_pct = %s,
                    completed_day = CASE WHEN %s = 'complete' THEN %s ELSE NULL END
                WHERE id = %s
            """, (new_builder_days, new_stage, new_status, pct, new_status, day, project_id))
        conn.commit()

    updated = get_project(project_id)
    return updated


def get_project(project_id: int) -> dict | None:
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT id, name, project_type, status, stage, progress_pct,
                       start_col, start_row, width_tiles, height_tiles,
                       proposed_by, assigned_builders, builder_days,
                       days_required, created_day, completed_day
                FROM construction_projects WHERE id = %s
            """, (project_id,))
            row = cur.fetchone()
    if not row:
        return None
    cols = ["id","name","project_type","status","stage","progress_pct",
            "start_col","start_row","width_tiles","height_tiles",
            "proposed_by","assigned_builders","builder_days",
            "days_required","created_day","completed_day"]
    return dict(zip(cols, row))


def get_all_active_projects() -> list[dict]:
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT id, name, project_type, status, stage, progress_pct,
                       start_col, start_row, width_tiles, height_tiles,
                       proposed_by, assigned_builders, builder_days, days_required
                FROM construction_projects
                WHERE status != 'complete'
                ORDER BY created_day
            """)
            rows = cur.fetchall()
    cols = ["id","name","project_type","status","stage","progress_pct",
            "start_col","start_row","width_tiles","height_tiles",
            "proposed_by","assigned_builders","builder_days","days_required"]
    return [dict(zip(cols, r)) for r in rows]
```

### 7.3 Changes to `src/dashboard/server.py`

Add these new API endpoints and broadcast helpers:

```python
# ADD to server.py — new endpoints

@app.get("/api/world")
async def get_world():
    """Return full world tile state. Called once on page load."""
    from src.world.tile_manager import get_world_state
    return get_world_state()

@app.get("/api/construction")
async def get_construction():
    """Return all active construction projects."""
    from src.world.construction_manager import get_all_active_projects
    return get_all_active_projects()

# ADD to broadcast() — include world state on initial connect
async def send_initial_state(ws: WebSocket):
    """Called when a new client connects. Sends full world state."""
    from src.world.tile_manager import get_world_state
    from src.world.construction_manager import get_all_active_projects

    # Existing city state
    city_state = load_city_state()  # existing function
    city_state["world_tiles"] = get_world_state()
    city_state["construction"] = get_all_active_projects()

    await ws.send_text(json.dumps({
        "type": "state",
        "data": city_state
    }, default=_json_serial))
```

### 7.4 Changes to `src/os/city_v3.py`

Add construction tick to the daily loop:

```python
# In the daily tick function (run_day or equivalent)

from src.world.construction_manager import advance_project, get_all_active_projects
from src.world.tile_manager import place_tile

async def _tick_construction(day: int, broadcast_fn):
    """Called once per day. Advances all active construction projects."""
    projects = get_all_active_projects()
    for project in projects:
        # Each assigned builder contributes one builder-day
        for builder_name in project["assigned_builders"]:
            updated = advance_project(project["id"], day)

            # Broadcast progress to all clients
            await broadcast_fn({
                "type": "construction_progress",
                "project_id": project["id"],
                "project_name": project["name"],
                "stage": updated["stage"],
                "status": updated["status"],
                "progress_pct": updated["progress_pct"],
                "col": project["start_col"],
                "row": project["start_row"],
                "builder": builder_name,
                "day": day
            })

            # When complete, place the actual building tile
            if updated["status"] == "complete":
                from src.world.construction_manager import BUILDING_TILE_MAP
                tile_type = BUILDING_TILE_MAP.get(project["project_type"], "warehouse")
                tile = place_tile(
                    project["start_col"], project["start_row"],
                    tile_type, layer=3,
                    built_by=project["proposed_by"], built_day=day
                )
                await broadcast_fn({
                    "type": "tile_placed",
                    "tile": tile,
                    "day": day
                })
            break  # one advance per project per day regardless of builder count
                   # builder count affects speed formula in advance_project()
```

---

## 8. WebSocket Event Protocol

### 8.1 Events FROM server TO browser

All existing events remain. New events added:

```typescript
// NEW: Sent once on connect — full world state
{
  type: "state",
  data: {
    day: number,
    agents: Agent[],
    vault: number,
    relationships: Relationship[],
    last_newspaper: { body: string },
    events: Event[],
    messages: Message[],
    // NEW FIELDS:
    world_tiles: Tile[],        // all non-grass tiles
    construction: Project[]     // all active construction projects
  }
}

// NEW: A single tile was placed/changed
{
  type: "tile_placed",
  tile: {
    col: number,
    row: number,
    tile_type: string,
    layer: number,
    built_by: string | null,
    built_day: number | null
  },
  day: number
}

// NEW: Construction project progress update
{
  type: "construction_progress",
  project_id: number,
  project_name: string,
  stage: number,          // 0-5
  status: string,         // planned|surveying|foundation|framing|finishing|complete
  progress_pct: number,   // 0.0 to 100.0
  col: number,            // project top-left tile
  row: number,
  builder: string,        // which builder contributed this tick
  day: number
}

// NEW: Agent changed action state or position
{
  type: "agent_state",
  agent: string,          // agent name
  action: string,         // idle|walking|building|talking|chasing|fleeing
  col: number,            // current tile position
  row: number,
  facing: string,         // north|south|east|west
  target_col?: number,    // for walking/chasing
  target_row?: number,
  day: number
}

// EXISTING but enhanced: agent message — add sender position
{
  type: "message",
  from: string,
  to: string,
  content: string,
  day: number,
  // NEW FIELDS:
  from_col: number,       // sender's tile position (for speech bubble)
  from_row: number,
  role: string
}
```

### 8.2 Events FROM browser TO server (future)

```typescript
// Click on a tile — request info
{ type: "tile_click", col: number, row: number }

// Right-click on agent — request full profile
{ type: "agent_inspect", agent: string }
```

---

## 9. Frontend Structure

### 9.1 New project layout

```
src/dashboard/static/game-v2/
├── package.json
├── tsconfig.json
├── vite.config.ts
├── index.html            ← Vite entry (replaces old game mount)
├── public/
│   └── assets/           ← all Kenney sprites (see §4.2)
└── src/
    ├── main.ts           ← PixiJS app init, WebSocket connect
    ├── types.ts          ← shared TypeScript interfaces
    │
    ├── engine/
    │   ├── IsoGrid.ts    ← isometric coordinate math
    │   ├── IsoWorld.ts   ← tile rendering, sprite pools
    │   └── Camera.ts     ← pan, zoom, follow-agent
    │
    ├── systems/
    │   ├── CharacterManager.ts   ← agent sprites, animation FSM
    │   ├── ConstructionManager.ts ← build stage rendering
    │   ├── PathFinder.ts         ← EasyStar wrapper
    │   ├── SpeechBubble.ts       ← conversation bubbles above heads
    │   └── EventHandler.ts       ← routes WS events to systems
    │
    ├── ui/
    │   ├── HUD.ts        ← day counter, population, vault
    │   ├── MiniMap.ts    ← small overview in corner
    │   └── Tooltip.ts    ← click agent to see stats
    │
    └── ws/
        └── WorldSocket.ts   ← WebSocket client, event dispatch
```

### 9.2 `vite.config.ts`

```typescript
import { defineConfig } from 'vite';

export default defineConfig({
  root: '.',
  base: '/game/',
  build: {
    outDir: '../dist',       // build output served by FastAPI
    emptyOutDir: true,
  },
  server: {
    port: 5173,
    proxy: {
      '/ws':  { target: 'ws://localhost:8000',  ws: true },
      '/api': { target: 'http://localhost:8000' },
    }
  }
});
```

### 9.3 `src/types.ts`

```typescript
// src/types.ts — shared interfaces used across all systems

export interface Tile {
  col: number;
  row: number;
  tile_type: string;
  layer: number;
  built_by: string | null;
  built_day: number | null;
}

export interface Agent {
  name: string;
  role: string;
  tokens: number;
  age_days: number;
  status: string;        // 'alive' | 'dead'
  mood: string;
  col: number;
  row: number;
  action: string;        // 'idle' | 'walking' | 'building' | 'talking' | 'chasing' | 'fleeing'
  facing: string;        // 'north' | 'south' | 'east' | 'west'
  home_col: number | null;
  home_row: number | null;
}

export interface ConstructionProject {
  id: number;
  name: string;
  project_type: string;
  status: string;
  stage: number;           // 0-5
  progress_pct: number;
  col: number;             // start_col
  row: number;             // start_row
  width_tiles: number;
  height_tiles: number;
  proposed_by: string;
  assigned_builders: string[];
  builder_days: number;
  days_required: number;
}

export interface Message {
  from: string;
  to: string;
  content: string;
  day: number;
  from_col: number;
  from_row: number;
  role: string;
}

export interface WorldState {
  day: number;
  agents: Agent[];
  vault: number;
  world_tiles: Tile[];
  construction: ConstructionProject[];
  messages: Message[];
  events: any[];
}
```

---

## 10. Isometric Engine Design

### 10.1 Coordinate systems

The game has three coordinate systems. You must never confuse them.

```
TILE coords    (col, row)      — integer grid position, 0 to 127
WORLD coords   (wx, wy)        — pixel position in the isometric world
SCREEN coords  (sx, sy)        — pixel position on the browser canvas (after camera transform)
```

### 10.2 `src/engine/IsoGrid.ts`

```typescript
// src/engine/IsoGrid.ts
// All coordinate math for the isometric grid.

export const TILE_W  = 64;   // tile width in pixels (Kenney standard)
export const TILE_H  = 32;   // tile height in pixels (half of width)
export const GRID_COLS = 128;
export const GRID_ROWS = 128;

// World size in pixels
export const WORLD_W = (GRID_COLS + GRID_ROWS) * (TILE_W / 2);
export const WORLD_H = (GRID_COLS + GRID_ROWS) * (TILE_H / 2);

/**
 * Convert tile coordinates to world pixel position.
 * The world pixel is the top-center of the tile diamond.
 */
export function tileToWorld(col: number, row: number): { x: number; y: number } {
  return {
    x: (col - row) * (TILE_W / 2),
    y: (col + row) * (TILE_H / 2),
  };
}

/**
 * Convert world pixel position back to tile coordinates.
 * Useful for mouse picking.
 */
export function worldToTile(wx: number, wy: number): { col: number; row: number } {
  return {
    col: Math.floor((wx / (TILE_W / 2) + wy / (TILE_H / 2)) / 2),
    row: Math.floor((wy / (TILE_H / 2) - wx / (TILE_W / 2)) / 2),
  };
}

/**
 * Depth sort order for isometric rendering.
 * Tiles with higher (col + row) are drawn last (appear in front).
 */
export function depthOrder(col: number, row: number, layer: number): number {
  return (col + row) * 10 + layer;
}

/**
 * Returns the 4 tiles adjacent to (col, row).
 */
export function getNeighbours(col: number, row: number): Array<{col: number, row: number}> {
  return [
    { col: col,     row: row - 1 },  // north
    { col: col + 1, row: row     },  // east
    { col: col,     row: row + 1 },  // south
    { col: col - 1, row: row     },  // west
  ].filter(t => t.col >= 0 && t.col < GRID_COLS && t.row >= 0 && t.row < GRID_ROWS);
}
```

### 10.3 `src/engine/IsoWorld.ts` — tile rendering

```typescript
// src/engine/IsoWorld.ts
// Manages the tile grid display. Uses PixiJS Container with depth sorting.

import * as PIXI from 'pixi.js';
import { tileToWorld, depthOrder, TILE_W, TILE_H, GRID_COLS, GRID_ROWS } from './IsoGrid';
import type { Tile } from '../types';

export class IsoWorld {
  private container: PIXI.Container;
  private tileSprites: Map<string, PIXI.Sprite> = new Map();  // key = "col,row,layer"

  constructor(stage: PIXI.Container) {
    this.container = new PIXI.Container();
    this.container.sortableChildren = true;   // enable depth sorting
    stage.addChild(this.container);
  }

  /**
   * Render the base grass grid.
   * Called once on init. Grass tiles cover the entire 128×128 grid.
   */
  async renderGrass() {
    const grassTexture = PIXI.Texture.from('grass');
    for (let col = 0; col < GRID_COLS; col++) {
      for (let row = 0; row < GRID_ROWS; row++) {
        this._placeSprite(col, row, 0, grassTexture);
      }
    }
  }

  /**
   * Place or replace a tile sprite from server data.
   */
  placeTile(tile: Tile) {
    const texture = PIXI.Texture.from(tile.tile_type);
    this._placeSprite(tile.col, tile.row, tile.layer, texture);
  }

  /**
   * Load all tiles from the initial world state.
   */
  loadWorldState(tiles: Tile[]) {
    tiles.forEach(t => this.placeTile(t));
  }

  private _placeSprite(col: number, row: number, layer: number, texture: PIXI.Texture) {
    const key = `${col},${row},${layer}`;
    const { x, y } = tileToWorld(col, row);

    // Remove existing sprite at this position+layer
    const existing = this.tileSprites.get(key);
    if (existing) { this.container.removeChild(existing); existing.destroy(); }

    const sprite = new PIXI.Sprite(texture);
    sprite.anchor.set(0.5, 1);  // anchor at bottom-center of tile diamond
    sprite.x = x;
    sprite.y = y;
    sprite.zIndex = depthOrder(col, row, layer);

    this.container.addChild(sprite);
    this.tileSprites.set(key, sprite);
  }

  get displayObject(): PIXI.Container { return this.container; }
}
```

---

## 11. Character Sprite System

### 11.1 Role → Kenney character mapping

Kenney's isometric character pack has characters differentiated by:
- Skin tone (6 variants)
- Clothing colour
- Accessories (hat, vest, etc.)

We map each AIcity role to a specific sprite:

```typescript
// src/systems/CharacterManager.ts — role config
export const ROLE_SPRITE_CONFIG: Record<string, {
  spriteKey: string;    // key in the Kenney spritesheet atlas
  tint: number;         // PixiJS hex tint to differentiate further
  scale: number;
}> = {
  builder:   { spriteKey: 'character_robot_a',  tint: 0xFF8C00, scale: 1.0 },
  police:    { spriteKey: 'character_robot_b',  tint: 0x4169E1, scale: 1.0 },
  thief:     { spriteKey: 'character_robot_c',  tint: 0x8B0000, scale: 1.0 },
  merchant:  { spriteKey: 'character_robot_d',  tint: 0xFFD700, scale: 1.0 },
  teacher:   { spriteKey: 'character_robot_e',  tint: 0x20B2AA, scale: 1.0 },
  healer:    { spriteKey: 'character_robot_f',  tint: 0xFF69B4, scale: 1.0 },
  messenger: { spriteKey: 'character_robot_a',  tint: 0x9370DB, scale: 1.0 },
  explorer:  { spriteKey: 'character_robot_b',  tint: 0x228B22, scale: 1.0 },
  lawyer:    { spriteKey: 'character_robot_c',  tint: 0x708090, scale: 1.0 },
  villain:   { spriteKey: 'character_robot_d',  tint: 0x2F4F4F, scale: 1.1 },
  gang:      { spriteKey: 'character_robot_e',  tint: 0xFF4500, scale: 1.0 },
  newborn:   { spriteKey: 'character_robot_f',  tint: 0xADD8E6, scale: 0.7 },
};
```

### 11.2 Animation states

Each character has these animation states. Kenney provides walk cycles per direction.

```typescript
export type AgentAction = 'idle' | 'walking' | 'building' | 'talking' | 'chasing' | 'fleeing';
export type FacingDir  = 'north' | 'south' | 'east' | 'west';

// Frame indices for each animation (from Kenney spritesheet)
// Kenney isometric characters: each direction has 2-4 walk frames
export const ANIM_FRAMES: Record<AgentAction, number[]> = {
  idle:     [0],               // single frame
  walking:  [0, 1, 2, 1],     // 4-frame walk cycle
  building: [0, 3, 0, 3],     // "swing" animation (arms up/down)
  talking:  [0, 4],            // slight head bob
  chasing:  [0, 1, 2, 1],     // same as walking but played faster
  fleeing:  [0, 1, 2, 1],     // same as walking but played fastest
};

export const ANIM_SPEED: Record<AgentAction, number> = {
  idle:     0,
  walking:  150,   // ms per frame
  building: 300,
  talking:  500,
  chasing:  80,
  fleeing:  70,
};
```

### 11.3 Movement — smooth interpolation

Agents don't teleport. They move smoothly using PixiJS tweens.

```typescript
// In CharacterManager.ts
moveAgentTo(name: string, targetCol: number, targetRow: number, onComplete?: () => void) {
  const entry = this.agents.get(name);
  if (!entry) return;

  // Use PathFinder to get waypoints
  this.pathFinder.findPath(
    entry.col, entry.row,
    targetCol, targetRow,
    (path) => {
      if (!path || path.length === 0) return;
      this._walkAlongPath(name, path, onComplete);
    }
  );
}

private _walkAlongPath(name: string, path: [number,number][], onComplete?: () => void) {
  const entry = this.agents.get(name);
  if (!entry || path.length === 0) { onComplete?.(); return; }

  const [nextCol, nextRow] = path[0];
  const target = tileToWorld(nextCol, nextRow);
  entry.data.action = 'walking';
  entry.data.facing = getFacingDir(entry.col, entry.row, nextCol, nextRow);
  this._updateAnimation(name);

  // PIXI tween: animate sprite position
  const tween = gsap.to(entry.sprite, {           // or use PixiJS ticker
    x: target.x,
    y: target.y,
    duration: 0.4,    // 400ms per tile
    ease: 'none',
    onComplete: () => {
      entry.col = nextCol;
      entry.row = nextRow;
      if (path.length > 1) {
        this._walkAlongPath(name, path.slice(1), onComplete);
      } else {
        entry.data.action = 'idle';
        this._updateAnimation(name);
        onComplete?.();
      }
    }
  });
}
```

> **Note on tween library**: Use `gsap` (free for non-commercial) or the
> lightweight `@tweenjs/tween.js` (MIT). Install:
> `npm install gsap` or `npm install @tweenjs/tween.js`

---

## 12. Construction System Design

### 12.1 Visual stages

When a construction project is received, the frontend renders a different sprite
at the project location for each stage:

| Stage | Backend status | Sprite shown | What player sees |
|-------|---------------|-------------|-----------------|
| 0 | `planned` | nothing | empty lot |
| 1 | `surveying` | `construction/stage_0_stakes.png` | wooden stakes in ground |
| 2 | `foundation` | `construction/stage_1_foundation.png` | concrete slab |
| 3 | `framing` | `construction/stage_2_frame.png` | skeleton frame going up |
| 4 | `finishing` | `construction/stage_3_walls.png` | walls, no roof yet |
| 5 | `complete` | actual building sprite (e.g. `market.png`) | finished building |

### 12.2 Builder animation at construction site

When a builder is assigned to a project:
1. The builder agent walks to the project tile (pathfinding)
2. On arrival, switches to `building` animation (arms moving)
3. A progress bar floats above the site
4. Other agents can stop and watch (idle facing the site)
5. On stage advance, dust particle effect + stage sprite swaps

```typescript
// In ConstructionManager.ts
onConstructionProgress(event: ConstructionProgressEvent) {
  const project = this.projects.get(event.project_id);
  if (!project) {
    // New project — add it
    this.projects.set(event.project_id, {
      ...event,
      progressBar: this._createProgressBar(event.col, event.row),
      stageSprite: this._createStageSprite(event.col, event.row, event.stage),
    });
    return;
  }

  // Update progress bar
  project.progressBar.update(event.progress_pct);

  // Advance stage sprite if stage changed
  if (event.stage !== project.stage) {
    project.stageSprite.destroy();
    project.stageSprite = this._createStageSprite(event.col, event.row, event.stage);
    this._dustEffect(event.col, event.row);   // visual feedback
  }

  // Move builder sprite to site
  this.characterManager.moveAgentTo(event.builder, event.col, event.row, () => {
    this.characterManager.setAction(event.builder, 'building');
  });

  Object.assign(project, event);
}

onConstructionComplete(tile: TileEvent) {
  // project.stageSprite is replaced by the final building tile
  // (tile_placed event handles this in IsoWorld)
  const project = this.findProjectAt(tile.col, tile.row);
  if (project) {
    project.progressBar.destroy();
    project.stageSprite.destroy();
    this.projects.delete(project.id);
    this._completionEffect(tile.col, tile.row);
  }
}
```

---

## 13. Pathfinding System

### 13.1 `src/systems/PathFinder.ts`

```typescript
// src/systems/PathFinder.ts
// EasyStar.js wrapper. Maintains a walkability grid.
// Agents can walk on: grass, road tiles, paths
// Agents cannot walk on: water, buildings (layer 3 occupied)

import EasyStar from 'easystarjs';
import { GRID_COLS, GRID_ROWS } from '../engine/IsoGrid';
import type { Tile } from '../types';

const WALKABLE    = 0;
const BLOCKED     = 1;

// Tile types that block movement
const BLOCKED_TYPES = new Set([
  'water',
  'house_small', 'house_medium', 'shop', 'hospital', 'school',
  'police_station', 'market', 'warehouse',
]);

export class PathFinder {
  private easystar: EasyStar.js;
  private grid: number[][];    // GRID_ROWS × GRID_COLS, 0=walkable 1=blocked

  constructor() {
    this.easystar = new EasyStar.js();
    // Init fully walkable grid
    this.grid = Array.from({ length: GRID_ROWS }, () =>
      new Array(GRID_COLS).fill(WALKABLE)
    );
    this.easystar.setGrid(this.grid);
    this.easystar.setAcceptableTiles([WALKABLE]);
    this.easystar.enableDiagonals();
    this.easystar.disableCornerCutting();
  }

  /**
   * Update walkability after a tile is placed.
   */
  onTilePlaced(tile: Tile) {
    if (tile.layer === 3 && BLOCKED_TYPES.has(tile.tile_type)) {
      this.setBlocked(tile.col, tile.row);
    }
    if (tile.tile_type === 'water') {
      this.setBlocked(tile.col, tile.row);
    }
    // Roads make tiles preferred (but all grass is walkable too)
    this.easystar.setGrid(this.grid);  // re-set after changes
  }

  setBlocked(col: number, row: number) {
    if (col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS) {
      this.grid[row][col] = BLOCKED;
    }
  }

  /**
   * Find a path from (fromCol, fromRow) to (toCol, toRow).
   * Calls callback with [[col,row], ...] waypoints, or null if no path.
   */
  findPath(
    fromCol: number, fromRow: number,
    toCol: number, toRow: number,
    callback: (path: [number, number][] | null) => void
  ) {
    this.easystar.findPath(fromCol, fromRow, toCol, toRow, (path) => {
      if (!path) { callback(null); return; }
      callback(path.map(p => [p.x, p.y]));
    });
    this.easystar.calculate();
  }
}
```

---

## 14. Sprint Plan

### Sprint 1 — Foundation (Days 1–3)
**Goal**: Empty world renders in browser. WebSocket connected.

| Task | File(s) | Detail |
|------|---------|--------|
| Set up Vite + TS project | `package.json`, `vite.config.ts` | See §9.2 |
| Install all dependencies | — | See §3.1 commands |
| Download Kenney assets | `public/assets/` | See §4.2 |
| Implement IsoGrid math | `engine/IsoGrid.ts` | See §10.2 |
| Create PixiJS app | `main.ts` | 800×600 canvas, stage setup |
| Render grass grid | `engine/IsoWorld.ts` | 128×128 grass tiles |
| Connect WebSocket | `ws/WorldSocket.ts` | Connect to existing backend |
| Handle `state` event | `systems/EventHandler.ts` | Load world_tiles from state |
| Camera controls | `engine/Camera.ts` | Mouse drag pan, scroll zoom |
| Run DB migrations | `migrations/009–011` | world_tiles, construction, roads |
| Add `/api/world` endpoint | `server.py` | Returns tile state |
| Generate initial world | `world/tile_manager.py` | River + trees (one-time) |

**Sprint 1 acceptance test**: Open browser, see green isometric grass field with
river running through it. Camera pans and zooms smoothly.

---

### Sprint 2 — Characters (Days 4–6)
**Goal**: All 10 agents are visible on the map, animate, and walk.

| Task | File(s) | Detail |
|------|---------|--------|
| Load Kenney character spritesheet | `systems/CharacterManager.ts` | Atlas load |
| Spawn agent sprites at world positions | CharacterManager | From state.agents |
| Role → sprite/tint mapping | CharacterManager | See §11.1 |
| Idle animation loop | CharacterManager | Frame cycling |
| Handle `agent_state` event | EventHandler | Update action + position |
| EasyStar pathfinder init | `systems/PathFinder.ts` | See §13 |
| Smooth movement along path | CharacterManager | 400ms per tile tween |
| Agent name label above sprite | CharacterManager | Small text, fades at zoom-out |
| Handle `positions` bulk update | EventHandler | Move all agents |
| Backend: emit `agent_state` events | `city_v3.py` | Per agent per action |

**Sprint 2 acceptance test**: Agents visible as distinct isometric characters.
Click City tab: see them walk toward zone centres. Each role is visually different.

---

### Sprint 3 — World Building (Days 7–10)
**Goal**: Roads and trees appear as agents make decisions.

| Task | File(s) | Detail |
|------|---------|--------|
| Backend: `tile_manager.py` | world/tile_manager.py | See §7.1 |
| DB migration 009 | migrations/ | world_tiles table |
| Hook builder decisions into tile placement | behaviors.py / city_v3.py | Builder places road tile |
| Frontend: handle `tile_placed` event | EventHandler → IsoWorld | Replace tile sprite |
| Road tile auto-connect logic | IsoWorld | Choose straight/corner/T based on neighbours |
| PathFinder updates on tile_placed | PathFinder.onTilePlaced | Block buildings |
| Trees placed by explorer/nature events | tile_manager.py | Explorer finds nice spot |
| `/api/world` endpoint | server.py | Returns full tile state |
| Send world_tiles in initial `state` | server.py | On connect |
| Rebuild world from state on reload | EventHandler | Full IsoWorld.loadWorldState() |

**Sprint 3 acceptance test**: Run simulation for 5 days. See a road segment appear.
Hard-refresh browser — road is still there (loaded from DB).

---

### Sprint 4 — Construction System (Days 11–14)
**Goal**: Multi-agent construction is visible, takes multiple days.

| Task | File(s) | Detail |
|------|---------|--------|
| DB migrations 010 | migrations/ | construction_projects |
| `construction_manager.py` | world/ | See §7.2 |
| Hook builder role behaviour to propose projects | behaviors.py | Builders propose builds |
| Daily tick: advance construction | city_v3.py | See §7.4 |
| Broadcast `construction_progress` | city_v3.py | Per builder per day |
| Frontend: `ConstructionManager.ts` | systems/ | See §12.2 |
| Stage sprite system | ConstructionManager | Stakes → foundation → frame |
| Floating progress bar above site | ConstructionManager | 0–100% |
| Builder walks to site | CharacterManager + PathFinder | moveTo site on assign |
| Dust particle effect on stage advance | ConstructionManager | Simple PIXI particles |
| `tile_placed` on complete | server.py | Final building tile |
| `/api/construction` endpoint | server.py | Active projects |

**Sprint 4 acceptance test**: Builder agent announces a market. You see stakes appear
next day, foundation the day after. Progress bar shows %. On completion, market
building sprite pops into place with dust effect.

---

### Sprint 5 — Social Drama (Days 15–18)
**Goal**: Conversations visible in world. Police chases are watchable.

| Task | File(s) | Detail |
|------|---------|--------|
| Speech bubble system | `systems/SpeechBubble.ts` | Appears above sender, fades 4s |
| Handle `message` events | EventHandler → SpeechBubble | Short excerpt above head |
| Police chase: moveTo criminal on arrest | CharacterManager | Chase pathfinding |
| Criminal flees: pathfind away | CharacterManager | Opposite direction |
| Villain lurk animation | CharacterManager | Slow pace near dark zone |
| Arrest animation | CharacterManager | Tackle at meeting point |
| `meeting` event: agents walk together | CharacterManager | Both moveTo meeting point |
| `death` event: gravestone tile | IsoWorld | Place gravestone sprite |
| `birth` event: agent spawns | CharacterManager | New sprite at town square |
| Gang cluster at dark alley | CharacterManager | Members move to alley zone |
| Healer rushes to cardiac victim | CharacterManager | moveTo on heart_attack |

**Sprint 5 acceptance test**: Watch a message event: speech bubble appears above
sender's head. Watch an arrest: police runs toward criminal, criminal runs away,
they meet, criminal turns grey.

---

### Sprint 6 — Polish (Days 19–21)
**Goal**: Feels like a real city sim.

| Task | Detail |
|------|--------|
| Camera auto-pan to events | On death, arrest, construction_complete — pan there |
| Click agent to follow | Click a sprite, camera follows that agent |
| Minimap | 200×200 overview in bottom-right corner |
| Agent tooltip on hover | Name, role, tokens, mood, top bonds |
| Night sky + lamp glow | Port existing DayNight.js system to PixiJS |
| Performance optimization | Sprite pooling, only render visible tiles |
| Loading screen | "AIcity is loading..." while assets download |
| Error states | Show red banner if WebSocket disconnects |

---

## 15. File Manifest

### Files to CREATE

```
src/world/
├── __init__.py
├── tile_manager.py          ← §7.1
└── construction_manager.py  ← §7.2

src/migrations/
├── 009_world_tiles.sql      ← §6.1
├── 010_construction_projects.sql ← §6.2
└── 011_road_network.sql     ← §6.3

src/dashboard/static/game-v2/
├── package.json
├── tsconfig.json
├── vite.config.ts           ← §9.2
├── public/assets/           ← download from Kenney
└── src/
    ├── main.ts
    ├── types.ts             ← §9.3
    ├── engine/
    │   ├── IsoGrid.ts       ← §10.2
    │   ├── IsoWorld.ts      ← §10.3
    │   └── Camera.ts
    ├── systems/
    │   ├── CharacterManager.ts  ← §11
    │   ├── ConstructionManager.ts ← §12
    │   ├── PathFinder.ts    ← §13
    │   ├── SpeechBubble.ts
    │   └── EventHandler.ts
    ├── ui/
    │   ├── HUD.ts
    │   ├── MiniMap.ts
    │   └── Tooltip.ts
    └── ws/
        └── WorldSocket.ts
```

### Files to MODIFY

```
src/dashboard/server.py          — add /api/world, /api/construction, new WS events
src/os/city_v3.py                — add construction tick, agent state broadcasts
src/agents/behaviors.py          — builders propose construction projects
src/dashboard/static/index.html  — replace game mount point with game-v2
```

### Files to DELETE (after game-v2 is working)

```
src/dashboard/static/game/       — entire old Phaser game folder
```

---

## 16. Environment Setup — Step by Step

### 16.1 Prerequisites

```bash
# Check these are installed
node --version   # need 18+
npm --version    # need 9+
python --version # need 3.11+
psql --version   # need 14+
brew --version   # Mac only
```

### 16.2 Frontend setup

```bash
cd /path/to/aicity/src/dashboard/static/

# Create Vite project inside game-v2/
mkdir game-v2
cd game-v2
npm create vite@latest . -- --template vanilla-ts
# Press Enter to accept all defaults

# Install game dependencies
npm install pixi.js@8
npm install easystarjs
npm install @types/easystarjs
npm install simplex-noise
npm install gsap               # for smooth tweens

# Verify
npm run dev
# Should open http://localhost:5173 with a default page
```

### 16.3 Download Kenney assets

```bash
# Manual download (browser):
# 1. Go to https://kenney.nl/assets/isometric-city-kit
# 2. Click Download
# 3. Unzip and copy PNG files to:
#    src/dashboard/static/game-v2/public/assets/tiles/buildings/
#    src/dashboard/static/game-v2/public/assets/tiles/roads/
#    etc. (follow §4.2 structure)

# For the character sprites:
# 1. Go to https://kenney.nl/assets/isometric-characters
# 2. Download and copy to:
#    src/dashboard/static/game-v2/public/assets/characters/
```

### 16.4 Backend: run new migrations

```bash
cd /path/to/aicity

# Run each migration
psql -U postgres -d aicity -f src/migrations/009_world_tiles.sql
psql -U postgres -d aicity -f src/migrations/010_construction_projects.sql
psql -U postgres -d aicity -f src/migrations/011_road_network.sql

# Optional: add agent world position columns
psql -U postgres -d aicity -c "
  ALTER TABLE agents
    ADD COLUMN IF NOT EXISTS world_col INTEGER DEFAULT 32,
    ADD COLUMN IF NOT EXISTS world_row INTEGER DEFAULT 32,
    ADD COLUMN IF NOT EXISTS current_action VARCHAR(64) DEFAULT 'idle',
    ADD COLUMN IF NOT EXISTS facing_dir VARCHAR(8) DEFAULT 'south';
"
```

### 16.5 Install new Python dependencies

```bash
pip install redis celery[redis]
# Only needed if you want parallel agent processing
# Skip if keeping single-threaded backend for now
```

### 16.6 Generate initial world

```bash
# Run once to populate world_tiles with river + trees
python -c "
from src.world.tile_manager import generate_initial_world
import math
n = generate_initial_world(day=0)
print(f'Generated {n} tiles')
"
```

### 16.7 Run the full stack

```bash
# Terminal 1: Backend
uvicorn src.dashboard.server:app --port 8000 --reload

# Terminal 2: Frontend (Vite dev server)
cd src/dashboard/static/game-v2
npm run dev
# Access at http://localhost:5173

# Terminal 3: Simulation
python main_phase3.py
```

### 16.8 Build for production

```bash
cd src/dashboard/static/game-v2
npm run build
# Output goes to src/dashboard/static/dist/
# FastAPI serves this at /game/ route
```

---

## 17. Testing Strategy

### Manual test checklist per sprint

**Sprint 1 — World rendering**
- [ ] Browser shows isometric grass grid
- [ ] River tiles (water) visible cutting through the map
- [ ] Trees scattered across the field
- [ ] Camera pans with mouse drag
- [ ] Camera zooms with scroll wheel
- [ ] Hard refresh — world reloads from server

**Sprint 2 — Characters**
- [ ] All alive agents appear as isometric sprites
- [ ] Each role has visually distinct tint/sprite
- [ ] Agents animate (walk cycle plays when moving)
- [ ] Agent names appear on hover/zoom-in
- [ ] Dead agents disappear from map

**Sprint 3 — World building**
- [ ] Reload after simulation ran — new tiles visible
- [ ] Road tiles connect visually (corner/T pieces auto-selected)
- [ ] Water tiles block agent pathfinding

**Sprint 4 — Construction**
- [ ] Stakes sprite appears when project enters `surveying`
- [ ] Foundation sprite appears on stage 2
- [ ] Builder agent walks to site
- [ ] Progress bar shows correct %
- [ ] Building sprite appears on completion
- [ ] Two builders = faster than one builder

**Sprint 5 — Social**
- [ ] Message event → speech bubble above sender
- [ ] Arrest → police pathfinds to criminal's position
- [ ] Gravestone tile placed on death
- [ ] Healer runs to heart attack victim

### Backend unit tests (add to `tests/`)

```python
# tests/test_construction.py
from src.world.construction_manager import propose_project, advance_project

def test_single_builder_takes_base_days():
    p = propose_project("Test Market", "market", 50, 50, 2, 2, "Atlas", 1)
    assert p["stage"] == 0
    # Advance 3 times (base_days for market = 3 per stage, 1 builder)
    for d in range(1, 4):
        p = advance_project(p["id"], d)
    assert p["stage"] == 1

def test_two_builders_faster():
    # base = 3, sqrt(2) ≈ 1.41, ceil(3/1.41) = 3 → same as 1?
    # Actually base=3, 2 builders: ceil(3/sqrt(2)) = ceil(2.12) = 3
    # 3 builders: ceil(3/sqrt(3)) = ceil(1.73) = 2 days per stage
    pass  # fill in exact numbers
```

---

## 18. Performance Targets

| Metric | Target |
|--------|--------|
| Initial load time | < 3 seconds (assets cached) |
| FPS with 20 agents + 128×128 grid | ≥ 60 FPS |
| FPS at zoom-out (full map visible) | ≥ 30 FPS |
| WebSocket message latency | < 100ms |
| Tile sprite count (max rendered) | ~4,000 visible tiles at any zoom |

### Performance strategies

1. **Viewport culling**: Only render tiles within camera view + 2 tile buffer.
   PixiJS `Container.cull = true` + `CullingMixin` handles this automatically.

2. **Sprite pooling**: Pre-allocate grass sprites, reuse them as camera pans.
   Don't create/destroy sprites — just move and re-texture.

3. **Atlas packing**: All tile textures in one PNG atlas = one GPU texture bind.
   Use `TexturePacker` (free tier) or `pixi-packer`.

4. **Agent culling**: Only animate agents within 15 tiles of camera centre.
   Distant agents use static idle frame.

5. **Chunk loading**: For 128×128 grid, divide into 16×16 tile chunks.
   Load chunks on demand as camera pans.

---

## 19. Known Hard Problems

### P1 — Road auto-connect
When a road tile is placed, the adjacent tiles need to update their sprite
to show the correct road piece (straight, corner, T-junction, cross).
This requires reading all 4 neighbours and choosing the right sprite key.

```typescript
// Logic in IsoWorld.ts
function getRoadSprite(col: number, row: number, tileMap: Map<string, Tile>): string {
  const n = tileMap.has(`${col},${row-1},1`);  // north neighbour is road?
  const s = tileMap.has(`${col},${row+1},1`);
  const e = tileMap.has(`${col+1},${row},1`);
  const w = tileMap.has(`${col-1},${row},1`);
  // 16 possible combinations → lookup table
  const key = `${+n}${+s}${+e}${+w}`;
  return ROAD_SPRITE_MAP[key] ?? 'road_straight_ns';
}
const ROAD_SPRITE_MAP: Record<string, string> = {
  '0000': 'road_straight_ns',  // isolated — default to NS
  '1001': 'road_corner_ne',
  '0110': 'road_corner_sw',
  '1111': 'road_cross',
  // ... all 16 cases
};
```

### P2 — Isometric Z-order
Buildings that are tall must correctly render in front of agents that are
"behind" them. The rule: draw everything at depth = `(col + row) * 10 + layer`.
Agents use layer = 2.5 (between roads at 1 and buildings at 3).

### P3 — Agent initial positions
Current backend tracks agents by zone ID, not tile coordinates.
Phase 6 needs agents to have real (col, row) positions.
Migration: add `world_col, world_row` to agents table.
In `city_v3.py`, assign a random position within the zone when agent spawns.

### P4 — Backend construction triggers
Currently the builder role earns tokens by working; it doesn't propose
specific construction projects. We need to add a step in the builder's daily
action where the LLM decides "I want to build X at coordinates Y,Z" and
this gets persisted as a construction project.

This requires a prompt change in `src/agents/behaviors.py`:
```python
# In builder's daily decision prompt, add:
"""
If you decide to start a construction project today, respond with JSON:
{
  "action": "propose_construction",
  "name": "Market Stall",
  "type": "market",
  "reason": "The city needs a place to trade"
}
Otherwise respond with your normal action.
"""
```

---

## Appendix A — Useful URLs

| Resource | URL |
|----------|-----|
| Kenney Isometric City Kit | https://kenney.nl/assets/isometric-city-kit |
| Kenney Isometric Characters | https://kenney.nl/assets/isometric-characters |
| Kenney Isometric Landscape | https://kenney.nl/assets/isometric-landscape |
| PixiJS v8 docs | https://pixijs.com/8.x/guides |
| PixiJS v8 examples | https://pixijs.com/8.x/examples |
| EasyStar.js repo | https://github.com/prettymuchbryce/easystarjs |
| simplex-noise npm | https://www.npmjs.com/package/simplex-noise |
| GSAP (free tweens) | https://gsap.com/docs/v3/ |
| Vite docs | https://vitejs.dev/guide/ |
| LangGraph docs | https://langchain-ai.github.io/langgraph/ |
| Piskel (pixel art, free) | https://www.piskelapp.com/ |

## Appendix B — Git Workflow

No new repository needed. Continue on the same repo.

```bash
# Recommended branch structure for Phase 6
git checkout -b phase6/sprint-1-foundation
# do sprint 1 work
git commit -m "feat(phase6/s1): empty isometric world renders"
git push origin phase6/sprint-1-foundation

# When sprint passes acceptance test, merge to main
git checkout main
git merge phase6/sprint-1-foundation
git push origin main

# Next sprint
git checkout -b phase6/sprint-2-characters
```

## Appendix C — Model Recommendation

| Task | Recommended model | Why |
|------|------------------|-----|
| Writing this doc, architecture decisions | Claude Opus 4.6 | Complex multi-step reasoning |
| Sprint implementation (code) | Claude Sonnet 4.6 | Fast, accurate, cheaper |
| Routine fixes, small edits | Claude Haiku 4.5 | Cost-efficient for simple tasks |
| Agent brains (Opus, Sonnet, Haiku) | Split by role as in §3.4 | Cost optimization |

For the frontend implementation sprints, Sonnet 4.6 is fully capable. The
spec in this document is clear enough that implementation is mechanical rather
than architecturally ambiguous. Use Opus if the implementation goes off-spec
and you need it to reason about trade-offs.

---

*End of Phase 6 Master Plan — AIcity*
*Generated: February 2026*
*Version: 1.0*
